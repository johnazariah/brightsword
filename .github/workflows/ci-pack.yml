name: CI - Pack and optional publish

on:
  push:
    branches: [ main ]
    tags: [ 'v*', 'swissknife-v*', 'feber-v*', 'crucible-v*', 'squid-v*' ]
  workflow_dispatch:
    inputs:
      publish:
        description: 'Publish action: publish-swissknife, publish-feber, publish-crucible, publish-squid (blank for no publish)'
        required: false
        default: ''

env:
  ARTIFACT_DIR: ./artifacts
  NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}

jobs:
  pack_swissknife:
    runs-on: ubuntu-latest
    outputs:
      bumped_versions: ${{ steps.publish_swissknife_step.outputs.bumped_versions }}
      SwissKnifeVersion: ${{ steps.publish_swissknife_step.outputs.SwissKnifeVersion }}
      FeberVersion: ${{ steps.publish_swissknife_step.outputs.FeberVersion }}
    # Run on normal pushes or when explicitly dispatched to publish swissknife
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'publish-swissknife' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore
        run: dotnet restore BrightSword.sln

      - name: Show bumped_versions from pack_swissknife (if any)
        run: |
          echo "bumped_versions from pack_swissknife: ${{ needs['pack_swissknife'].outputs.bumped_versions }}"
          echo "SwissKnifeVersion: ${{ needs['pack_swissknife'].outputs.SwissKnifeVersion }}"
          echo "FeberVersion: ${{ needs['pack_swissknife'].outputs.FeberVersion }}"

      - name: Build
        run: dotnet build BrightSword.sln -c Release --no-restore

      - name: Run PublishSwissknife target (MSBuild)
        id: publish_swissknife_step
        env:
          GITHUB_REF_NAME: ${{ github.ref_name }}
          DO_COMMIT: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'publish-swissknife') || startsWith(github.ref, 'refs/tags/swissknife-v') }}
        run: |
          TAG=""
          if [[ "$GITHUB_REF" =~ ^refs/tags/swissknife-v ]]; then
            TAG=${GITHUB_REF#refs/tags/swissknife-v}
          fi
          echo "Invoking msbuild PublishSwissknife (VersionFromTag=$TAG)"
          dotnet msbuild build.proj -t:PublishSwissknife -p:DoCommit=$DO_COMMIT -p:NUGET_API_KEY=$NUGET_API_KEY -p:GitRefName=$GITHUB_REF_NAME -p:VersionFromTag=$TAG

      - name: Upload NuGet artifact
        uses: actions/upload-artifact@v4
        with:
          name: swissknife-nugets
          path: ${{ env.ARTIFACT_DIR }}

  pack-feber:
    runs-on: ubuntu-latest
    needs: pack_swissknife
    outputs:
      bumped_versions: ${{ steps.publish_feber_step.outputs.bumped_versions }}
    # Run on normal pushes, or when dispatch publishes feber or swissknife (swissknife publishes feber transitively)
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'publish-feber' || github.event.inputs.publish == 'publish-swissknife' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      # NOTE: We intentionally do NOT add a PackageReference to the Feber csproj here.
      # Both projects are packed independently so each produces its own NuGet package.

      - name: Restore
        run: dotnet restore BrightSword.sln

      - name: Run PublishFeber target (MSBuild)
        id: publish_feber_step
        env:
          GITHUB_REF_NAME: ${{ github.ref_name }}
          DO_COMMIT: ${{ (github.event_name == 'workflow_dispatch' && (github.event.inputs.publish == 'publish-feber' || github.event.inputs.publish == 'publish-swissknife')) || startsWith(github.ref, 'refs/tags/feber-v') || startsWith(github.ref, 'refs/tags/swissknife-v') }}
        run: |
          TAG=""
          if [[ "$GITHUB_REF" =~ ^refs/tags/feber-v ]]; then
            TAG=${GITHUB_REF#refs/tags/feber-v}
          fi
          echo "Invoking msbuild PublishFeber (VersionFromTag=$TAG)"
          dotnet msbuild build.proj -t:PublishFeber -p:DoCommit=$DO_COMMIT -p:NUGET_API_KEY=$NUGET_API_KEY -p:GitRefName=$GITHUB_REF_NAME -p:VersionFromTag=$TAG

      - name: Upload Feber NuGet artifact
        uses: actions/upload-artifact@v4
        with:
          name: feber-nugets
          path: ${{ env.ARTIFACT_DIR }}

      - name: "Optional: Publish packages to NuGet.org"
        run: |
          if [ -n "$(ls $ARTIFACT_DIR/*.nupkg 2>/dev/null)" ] && [ -n "$NUGET_API_KEY" ]; then
            echo "Publishing packages to NuGet.org"
            for nupkg in $ARTIFACT_DIR/*.nupkg; do
              echo "Pushing $nupkg"
              dotnet nuget push "$nupkg" -k $NUGET_API_KEY -s https://api.nuget.org/v3/index.json || echo "Push failed for $nupkg"
            done
          else
            echo "Skipping NuGet publish - no nupkg artifacts or NUGET_API_KEY missing"
          fi

  pack-crucible:
    runs-on: ubuntu-latest
    needs: pack-feber
    outputs:
      bumped_versions: ${{ steps.publish_crucible_step.outputs.bumped_versions }}
    # Run on normal pushes, or when explicitly dispatched to publish crucible
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'publish-crucible' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore
        run: dotnet restore BrightSword.sln

      - name: Run PublishCrucible target (MSBuild)
        id: publish_crucible_step
        env:
          GITHUB_REF_NAME: ${{ github.ref_name }}
          DO_COMMIT: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'publish-crucible') || startsWith(github.ref, 'refs/tags/crucible-v') }}
        run: |
          TAG=""
          if [[ "$GITHUB_REF" =~ ^refs/tags/crucible-v ]]; then
            TAG=${GITHUB_REF#refs/tags/crucible-v}
          fi
          echo "Invoking msbuild PublishCrucible (VersionFromTag=$TAG)"
          dotnet msbuild build.proj -t:PublishCrucible -p:DoCommit=$DO_COMMIT -p:NUGET_API_KEY=$NUGET_API_KEY -p:GitRefName=$GITHUB_REF_NAME -p:VersionFromTag=$TAG

      - name: Upload Crucible NuGet artifact
        uses: actions/upload-artifact@v4
        with:
          name: crucible-nugets
          path: ${{ env.ARTIFACT_DIR }}

      - name: "Optional: Publish Crucible packages to NuGet.org"
        run: |
          if [ -n "$(ls $ARTIFACT_DIR/*.nupkg 2>/dev/null)" ] && [ -n "$NUGET_API_KEY" ]; then
            echo "Publishing packages to NuGet.org"
            for nupkg in $ARTIFACT_DIR/*.nupkg; do
              echo "Pushing $nupkg"
              dotnet nuget push "$nupkg" -k $NUGET_API_KEY -s https://api.nuget.org/v3/index.json || echo "Push failed for $nupkg"
            done
          else
            echo "Skipping NuGet publish - no nupkg artifacts or NUGET_API_KEY missing"
          fi

  pack-squid:
    runs-on: ubuntu-latest
    needs: pack-crucible
    outputs:
      bumped_versions: ${{ steps.publish_squid_step.outputs.bumped_versions }}
    # Run on normal pushes, or when explicitly dispatched to publish squid
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'publish-squid' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore
        run: dotnet restore BrightSword.sln

      - name: Run PublishSquid target (MSBuild)
        id: publish_squid_step
        env:
          GITHUB_REF_NAME: ${{ github.ref_name }}
          DO_COMMIT: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'publish-squid') || startsWith(github.ref, 'refs/tags/squid-v') }}
        run: |
          TAG=""
          if [[ "$GITHUB_REF" =~ ^refs/tags/squid-v ]]; then
            TAG=${GITHUB_REF#refs/tags/squid-v}
          fi
          echo "Invoking msbuild PublishSquid (VersionFromTag=$TAG)"
          dotnet msbuild build.proj -t:PublishSquid -p:DoCommit=$DO_COMMIT -p:NUGET_API_KEY=$NUGET_API_KEY -p:GitRefName=$GITHUB_REF_NAME -p:VersionFromTag=$TAG

      - name: Upload Squid NuGet artifact
        uses: actions/upload-artifact@v4
        with:
          name: squid-nugets
          path: ${{ env.ARTIFACT_DIR }}

      - name: "Optional: Publish Squid packages to NuGet.org"
        run: |
          if [ -n "$(ls $ARTIFACT_DIR/*.nupkg 2>/dev/null)" ] && [ -n "$NUGET_API_KEY" ]; then
            echo "Publishing packages to NuGet.org"
            for nupkg in $ARTIFACT_DIR/*.nupkg; do
              echo "Pushing $nupkg"
              dotnet nuget push "$nupkg" -k $NUGET_API_KEY -s https://api.nuget.org/v3/index.json || echo "Push failed for $nupkg"
            done
          else
            echo "Skipping NuGet publish - no nupkg artifacts or NUGET_API_KEY missing"
          fi

  smoke_sample:
    runs-on: ubuntu-latest
    needs: pack-squid
    if: ${{ github.event_name != 'pull_request' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET (pinned SDK from global.json)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.100-rc.1.25451.107'

      - name: Restore
        run: dotnet restore BrightSword.sln

      - name: Run sample app (smoke)
        run: |
          echo "Running BrightSword.Feber.SamplesApp as a smoke test"
          dotnet run --project BrightSword.Feber.SamplesApp/BrightSword.Feber.SamplesApp.csproj --configuration Release --no-restore
